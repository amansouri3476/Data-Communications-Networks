%% Q6 Making Data
clc
close all
numOfBits = 100*1024;% assuming each KB is 1024 bits
out = randsrc(numOfBits,1,[0 1]);
Mean = mean(out);
Var = var(out);
%% Q7 and Q9 Modulation
alphabetSize = 4;
initialPhase = 0;
symbolIndex = 1 : log2(alphabetSize) : numOfBits-log2(alphabetSize)+1-mod(numOfBits,log2(alphabetSize));
outConvert = zeros(length(symbolIndex),1); % Preallocation
for i = 1 : length(symbolIndex)
    
    outConvert(i) = convertBase(out(symbolIndex(i):symbolIndex(i)+log2(alphabetSize)-1,1));
    
end
outMod = pskmod(outConvert,alphabetSize,initialPhase,'Gray');
scatterplot(outMod);
%% Q8 Demodulation
outDemod = pskdemod(outMod,alphabetSize,initialPhase,'Gray');
%% Q9 Changing Parameters of pskmod
% changing alphabet size (second argument)
outMod = pskmod(outConvert,8,initialPhase,'Gray');
scatterplot(outMod);
title('Changing alphabet size','color','r');
% changing initial phase (third argument)
outMod = pskmod(outConvert,4,1,'Gray');
scatterplot(outMod);
title('Changing initial phase','color','r');
% changing symbol order (fourth argument)
outMod = pskmod(outConvert,4,initialPhase,'bin');
scatterplot(outMod);
title('Changing symbol order','color','r');
%% Q10 to Q15
clc
close all
% They have been explained in the report
%% Q16
clc
close all
numOfSubCarriers = 64;
outMod = pskmod(outConvert,alphabetSize,initialPhase,'Gray');
% outMod = outMod(1:floor(length(outConvert)/numOfSubCarriers)*numOfSubCarriers,1);% adjusting for proper reshape
outModParalleled = reshape(outMod,[numOfSubCarriers,numOfBits/((alphabetSize/2)*numOfSubCarriers)]);
OFDMtimeDomain = ifft(outModParalleled);
OFDMtimeDomain = reshape(OFDMtimeDomain,[numOfBits/(alphabetSize/2),1]);
figure
subplot(1,2,1)
plot(real(OFDMtimeDomain))
xlim([1,length(OFDMtimeDomain)])
ylabel('Amplitude','color','b');
title('OFDM Signal Real Part','color','r')
subplot(1,2,2)
plot(imag(OFDMtimeDomain))
xlim([1,length(OFDMtimeDomain)])
ylabel('Amplitude','color','b');
title('OFDM Signal Imaginary Part','color','r')

% Calculating PAPR for absolute magnitude of signal
PAPR = (max(abs(OFDMtimeDomain)))^2/(rms(abs(OFDMtimeDomain)))^2;
PAPRdB = 10*log10(PAPR);
% Calculating PAPR for real part
PAPRreal = (max(real(OFDMtimeDomain)))^2/(rms(real(OFDMtimeDomain)))^2;
PAPRrealdB = 10*log10(PAPRreal);
% Calculating PAPR for imaginary part
PAPRimag = (max(imag(OFDMtimeDomain)))^2/(rms(imag(OFDMtimeDomain)))^2;
PAPRimagdB = 10*log10(PAPRimag);

%% Q18
clc
close all
interpolationRate = 2;
pwelch(interp(OFDMtimeDomain,interpolationRate),[],[],[],'centered');
% figure
% pwelch(interp(OFDMtimeDomain,1));
%% Q20
clc
close all
SNR = 10;
noisyDataReceived = awgn(OFDMtimeDomain,SNR,'measured');
% Serial to parallel
noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/((alphabetSize/2)*numOfSubCarriers)]);
fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);
% Parallel to serial
fftnoisyDataReceivedSerialed = reshape(fftnoisyDataReceivedParalled,[numOfBits/(alphabetSize/2),1]);
scatterplot(fftnoisyDataReceivedSerialed);
title(sprintf('Received Symbols Constellation Diagram for SNR = %ddB',SNR),'color','r')
%% Q21
clc
close all

SNR = 0 : 0.5 : 12;

for k = 1 : length(SNR)
        disp(length(SNR)-k);% To show how much is remaining for this part to end
        noisyDataReceived = awgn(OFDMtimeDomain,SNR(k),'measured');
        % Serial to parallel
        noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/((alphabetSize/2)*numOfSubCarriers)]);
        fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);
        % Parallel to serial
        fftnoisyDataReceivedSerialed = reshape(fftnoisyDataReceivedParalled,[numOfBits/(alphabetSize/2),1]);
        outDemod = pskdemod(fftnoisyDataReceivedSerialed,alphabetSize,initialPhase,'Gray');
        outDemodTemp = outDemod;
        % Decoding to get transimtted bits
        output = [];
        for i = 1 : length(outDemod)

           for j = 1 : log2(alphabetSize) 
                outputBits(j,1) = mod(outDemodTemp(i),2);
                outDemodTemp(i) = floor(outDemodTemp(i)/2);
           end

           output = [output;outputBits] ;
        end

        BER(k,1) = sum(xor(out,output))/numOfBits;
end
%% Q21 Plotting BER vs. SNR
figure
subplot(1,2,1)
semilogy(SNR,BER,'.');% for better visualization we use semilog diagram
xlabel('SNR (dB)','color','b')
ylabel('BER','color','b')
title('SNR Vs. BER (Scatter Plot)','color','r')
subplot(1,2,2)
semilogy(SNR,BER);% for better visualization we use semilog diagram
xlabel('SNR (dB)','color','b')
ylabel('BER','color','b')
title('SNR Vs. BER (Continuous)','color','r')
%% Q24 OFDM PSD Generated by user 10
clc
close all
numOfBits = 20*1024; % Decreasing Data size for speed improvement
alphabetSize = 4;
symbolIndex = 1 : log2(alphabetSize) : numOfBits-log2(alphabetSize)+1-mod(numOfBits,log2(alphabetSize));
% Generating user 10 data
user = 10;
users = 1 : 1 : 32;
% variables are cell typed in order to be used for each user individually
out = {};
outConvert = {};
outMod = {};
outModParalleled = {};
OFDMtimeDomain = {};
for i = 1 : length(users)
        out{i} = randsrc(numOfBits,1,[0 1]);
        for j = 1 : length(symbolIndex)
    
            outConvert{i}(j,1) = convertBase(out{i}(symbolIndex(j):symbolIndex(j)+log2(alphabetSize)-1,1));
    
        end
        
        % Modulating users' data
        
        outModTemp(:,1) = pskmod(outConvert{i},alphabetSize,initialPhase,'Gray');
        outMod{i} = zeros((length(outConvert{i})*numOfSubCarriers/2),1);
        % Separating modulated bits which must be in ith and i + 32 th places
        odd = 1 : 2 : length(outConvert{i})-1;
        even = 2 : 2 : length(outConvert{i});
        for j = 1 : length(outConvert{i})/2 % number of 64 columns(each 2 symbol require one column)
    
                outMod{i}((j-1)*numOfSubCarriers+i,1) = outModTemp(odd(j),1);
                outMod{i}((j-1)*numOfSubCarriers+i+32,1) = outModTemp(even(j),1);
    
        end
        
        % Reshaping to enter IFFT block

        outModParalleled{i} = reshape(outMod{i},[numOfSubCarriers,length(outConvert{i})/2]);

        % Passing through IFFT block

        OFDMtimeDomain{i} = ifft(outModParalleled{i});
        
        % Parallel to serial

        OFDMtimeDomain{i} = reshape(OFDMtimeDomain{i},[numOfSubCarriers*length(outConvert{i})/2,1]);
        
end

% Resulting OFDM time Domain signal

OFDMtimeDomainFinal = zeros(length(OFDMtimeDomain{1}),1);

for i = 1 : length(users)
        
        OFDMtimeDomainFinal = OFDMtimeDomainFinal + OFDMtimeDomain{i};
        
end

% Plotting PSD

pwelch(OFDMtimeDomain{user},[],[],[],'centered');

%% Q25 BER Vs. SNR for user #10
clc
close all

SNR = 0 : 0.5 : 12;
% variables are cell typed in order to be used for each user individually
noisyDataReceivedParalled = {};
outDemod = {};
fftnoisyDataReceivedSerialedChannelPicked = {};
fftnoisyDataReceivedParalled = {};
BER = [];
for k = 1 : length(SNR)
        disp(length(SNR)-k);% To show how much is remaining for this part to end
        noisyDataReceived = awgn(OFDMtimeDomainFinal,SNR(k),'measured');
        
        % Serial to parallel
        noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/(2*(alphabetSize/2))]);
        fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);

        % picking user #10's channels (channels #10 & #42)
        for i = 1 : length(outConvert{user})/2 % number of 64 columns(each 2 symbol require one column)
    
            fftnoisyDataReceivedSerialedChannelPicked{user}(2*(i-1)+1,1) = fftnoisyDataReceivedParalled(user,i);
            fftnoisyDataReceivedSerialedChannelPicked{user}(2*(i-1)+2,1) = fftnoisyDataReceivedParalled(user+32,i);
        
        end
        % scatterplot(fftnoisyDataReceivedSerialedChannelPicked{user});
        % Serialization is done above
        
        outDemod{user} = pskdemod(fftnoisyDataReceivedSerialedChannelPicked{user},alphabetSize,initialPhase,'Gray');
        outDemodTemp = outDemod{user};
        % Decoding to get transimtted bits
        output = [];
        for i = 1 : length(outDemod{user})

           for j = 1 : log2(alphabetSize) % code works for M other than 4
                outputBits(j,1) = mod(outDemodTemp(i),2);
                outDemodTemp(i) = floor(outDemodTemp(i)/2);
           end

           output = [output;outputBits] ;
        end

        BER(k,1) = sum(xor(out{user},output))/numOfBits;
end
%% Plotting the result
clc
close all
figure
subplot(1,2,1)
semilogy(SNR,BER,'.');% for better visualization we use semilog diagram
xlabel('SNR (dB)','color','b')
ylabel('BER','color','b')
title('SNR Vs. BER (Scatter Plot)','color','r')
subplot(1,2,2)
semilogy(SNR,BER);% for better visualization we use semilog diagram
xlabel('SNR (dB)','color','b')
ylabel('BER','color','b')
title('SNR Vs. BER (Continuous)','color','r')
suptitle('BER Vs. SNR for user 10')

%% Q26
clc
close all
innerProduct = dot(OFDMtimeDomain{10},OFDMtimeDomain{20});
%% Q27 and Q28 (Delay effect alongside with channel noise)

% We will choose a normal level for SNR (SNR = 10)
users = [5 15 25];
tmp = interp(OFDMtimeDomainFinal,40);
chanInDelay = decimate(tmp(2:end),40);
SNR = 10;
BER = []; % clearing saved data from this vector
for m = 1 : length(users)
        
                noisyDataReceived = awgn(chanInDelay,SNR,'measured');

                % Serial to parallel
                noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/(2*(alphabetSize/2))]);
                fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);

                % picking user's channels
                for i = 1 : length(outConvert{user})/2 % number of 64 columns(each 2 symbol require one column)

                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+1,1) = fftnoisyDataReceivedParalled(users(m),i);
                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+2,1) = fftnoisyDataReceivedParalled(users(m)+32,i);

                end
                scatterplot(fftnoisyDataReceivedSerialedChannelPicked{users(m)});
                title(sprintf('Scatter plot for user #%d',users(m)),'color','r');
                % Serialization is done above

                outDemod{users(m)} = pskdemod(fftnoisyDataReceivedSerialedChannelPicked{users(m)},alphabetSize,initialPhase,'Gray');
                outDemodTemp = outDemod{users(m)};
                % Decoding to get transimtted bits
                output = [];
                for i = 1 : length(outDemod{users(m)})

                   for j = 1 : log2(alphabetSize) % code works for M other than 4
                        outputBits(j,1) = mod(outDemodTemp(i),2);
                        outDemodTemp(i) = floor(outDemodTemp(i)/2);
                   end

                   output = [output;outputBits] ;
                end

                BER(m,1) = sum(xor(out{users(m)},output))/numOfBits;
       
end

%% Q27 and Q28 (Delay effect without channel noise)
clc
close all
users = [5 15 25];
tmp = interp(OFDMtimeDomainFinal,40);
chanInDelay = decimate(tmp(2:end),40);
BER = []; % clearing saved data from this vector
for m = 1 : length(users)
        
                noisyDataReceived = chanInDelay; % No noise is added to received data

                % Serial to parallel
                noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/(2*(alphabetSize/2))]);
                fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);

                % picking user's channels
                for i = 1 : length(outConvert{user})/2 % number of 64 columns(each 2 symbol require one column)

                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+1,1) = fftnoisyDataReceivedParalled(users(m),i);
                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+2,1) = fftnoisyDataReceivedParalled(users(m)+32,i);

                end
                scatterplot(fftnoisyDataReceivedSerialedChannelPicked{users(m)});
                title(sprintf('Scatter plot for user #%d',users(m)),'color','r');
                % Serialization is done above

                outDemod{users(m)} = pskdemod(fftnoisyDataReceivedSerialedChannelPicked{users(m)},alphabetSize,initialPhase,'Gray');
                outDemodTemp = outDemod{users(m)};
                % Decoding to get transimtted bits
                output = [];
                for i = 1 : length(outDemod{users(m)})

                   for j = 1 : log2(alphabetSize) % code works for M other than 4
                        outputBits(j,1) = mod(outDemodTemp(i),2);
                        outDemodTemp(i) = floor(outDemodTemp(i)/2);
                   end

                   output = [output;outputBits] ;
                end

                BER(m,1) = sum(xor(out{users(m)},output))/numOfBits;
       
end

%% Q30 (ISI effect alongside with channel noise)
clc
close all
% We will choose a normal level for SNR (SNR = 10)
users = [5 15 25];
chanResp = [1, 0.4, 0.1, 0.01];
chanInISI = filter(chanResp,1,OFDMtimeDomainFinal);
SNR = 10;
BER = []; % clearing saved data from this vector
for m = 1 : length(users)
        
                noisyDataReceived = awgn(chanInISI,SNR,'measured');

                % Serial to parallel
                noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/(2*(alphabetSize/2))]);
                fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);

                % picking user's channels
                for i = 1 : length(outConvert{user})/2 % number of 64 columns(each 2 symbol require one column)

                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+1,1) = fftnoisyDataReceivedParalled(users(m),i);
                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+2,1) = fftnoisyDataReceivedParalled(users(m)+32,i);

                end
                scatterplot(fftnoisyDataReceivedSerialedChannelPicked{users(m)});
                title(sprintf('Scatter plot for user #%d',users(m)),'color','r');
                % Serialization is done above

                outDemod{users(m)} = pskdemod(fftnoisyDataReceivedSerialedChannelPicked{users(m)},alphabetSize,initialPhase,'Gray');
                outDemodTemp = outDemod{users(m)};
                % Decoding to get transimtted bits
                output = [];
                for i = 1 : length(outDemod{users(m)})

                   for j = 1 : log2(alphabetSize) % code works for M other than 4
                        outputBits(j,1) = mod(outDemodTemp(i),2);
                        outDemodTemp(i) = floor(outDemodTemp(i)/2);
                   end

                   output = [output;outputBits] ;
                end

                BER(m,1) = sum(xor(out{users(m)},output))/numOfBits;
       
end

%% Q30 (ISI effect without channel noise)
clc
close all
users = [5 15 25];
chanResp = [1, 0.4, 0.1, 0.01];
chanInISI = filter(chanResp,1,OFDMtimeDomainFinal);
BER = []; % clearing saved data from this vector
for m = 1 : length(users)
        
                noisyDataReceived = chanInISI; % No noise is added to received data

                % Serial to parallel
                noisyDataReceivedParalled = reshape(noisyDataReceived,[numOfSubCarriers,numOfBits/(2*(alphabetSize/2))]);
                fftnoisyDataReceivedParalled = fft(noisyDataReceivedParalled);

                % picking user's channels
                for i = 1 : length(outConvert{user})/2 % number of 64 columns(each 2 symbol require one column)

                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+1,1) = fftnoisyDataReceivedParalled(users(m),i);
                    fftnoisyDataReceivedSerialedChannelPicked{users(m)}(2*(i-1)+2,1) = fftnoisyDataReceivedParalled(users(m)+32,i);

                end
                scatterplot(fftnoisyDataReceivedSerialedChannelPicked{users(m)});
                title(sprintf('Scatter plot for user #%d',users(m)),'color','r');
                % Serialization is done above

                outDemod{users(m)} = pskdemod(fftnoisyDataReceivedSerialedChannelPicked{users(m)},alphabetSize,initialPhase,'Gray');
                outDemodTemp = outDemod{users(m)};
                % Decoding to get transimtted bits
                output = [];
                for i = 1 : length(outDemod{users(m)})

                   for j = 1 : log2(alphabetSize) % code works for M other than 4
                        outputBits(j,1) = mod(outDemodTemp(i),2);
                        outDemodTemp(i) = floor(outDemodTemp(i)/2);
                   end

                   output = [output;outputBits] ;
                end

                BER(m,1) = sum(xor(out{users(m)},output))/numOfBits;
       
end